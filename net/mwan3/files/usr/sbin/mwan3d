#! /usr/bin/ucode -S

import { popen, readfile } from 'fs';
import { cursor } from 'uci';
import * as uloop from 'uloop';

const ubus = require('ubus').connect();

if (uloop.init() != true) {
	warn('uloop.init() failed');

	exit(1);
}

function get_str_raw(iface, property) {
	return readfile(sprintf('/var/run/mwan3track/%s/%s', iface, property));
}

function get_str(iface, property) {
	return rtrim(get_str_raw(iface, property), '\n');
}

function get_int(iface, property) {
	return int(get_str(iface, property));
}

function get_uptime() {
	return int(split(readfile('/proc/uptime'), '.', 2)[0]);
}

function get_x_time(uptime, iface, property) {
	let t = get_int(iface, property);
	if (t > 0) {
		t = uptime - t;
	}
	return t;
}

function ucibool(val) {
	switch (val) {
		case 'yes':
		case 'on':
		case 'true':
		case 'enabled':
			return true;
		default:
			return !!int(val);
	}
}

const interfaces = {};

cursor().foreach('mwan3', 'interface', interface => {
	interfaces[interface['.name']] = {
		'config': {
			'enabled': ucibool(interface['enabled']),
			'track_ip': interface['track_ip'],
		},
	};
});

function get_mwan3track_status(iface, uci_track_ips, procd) {
	if (length(uci_track_ips) == 0) {
		return 'disabled';
	}
	if (procd?.[sprintf('track_%s', iface)]?.running) {
		const started = get_str(iface, 'STARTED');
		switch (started) {
			case '0':
				return 'paused';
			case '1':
				return 'active';
			default:
				return 'down';
		}
	}
	return 'down';
}

const connected_check_cmd = {
	'4': 'iptables -t mangle -w -S mwan3_connected_ipv4',
	'6': 'ip6tables -t mangle -w -S mwan3_connected_ipv6',
};
const ipset_save_re = regexp('^add mwan3_connected_ipv[46] (.*)\n$');

function get_connected_ips(version) {
	const check = popen(connected_check_cmd[version], 'r');
	check.read('all');
	if (check.close() != 0) {
		return [];
	}
	const ipset = popen(sprintf('ipset -o save list mwan3_connected_ipv%s', version), 'r');
	const ips = [];
	for (let line = ipset.read('line'); length(line); line = ipset.read('line')) {
		const m = match(line, ipset_save_re);
		if (length(m) == 2) {
			push(ips, m[1]);
		}
	}
	ipset.close();
	return ips;
}

const policies_cmd = {
	'4': 'iptables -t mangle -w -S',
	'6': 'ip6tables -t mangle -w -S'
};
const policies_re = regexp('^-A mwan3_policy_([^ ]+) .*?--comment "([^"]+)"');

function get_policies(version) {
	const ipt = popen(policies_cmd[version], 'r');
	const policies = {};
	for (let line = ipt.read('line'); length(line); line = ipt.read('line')) {
		const m = match(line, policies_re);
		if (m == null) {
			continue;
		}
		const policy = m[1];
		if (!exists(policies, policy)) {
			policies[policy] = [];
		}
		const intfw = split(m[2], ' ', 3);
		const weight = int(intfw[1]);
		const total = int(intfw[2]);
		if (weight >= 0 && total > 0) {
			push(policies[policy], {
				'interface': intfw[0],
				'percent': weight / total * 100,
			})
		}
	}
	ipt.close();
	return policies;
}

function interfaces_status(request) {
	const procd = ubus.call('service', 'list', { 'name': 'mwan3' })?.mwan3?.instances;
	const result = {};
	for (let interface_name, interface_data in interfaces) {
		if (request.args.interface != null && request.args.interface != interface_name) {
			return;
		}
		const netstatus = ubus.call(sprintf('network.interface.%s', interface_name), 'status', {});
		const uptime = get_uptime();
		const uci_track_ips = interface_data.config.track_ip;
		const track_status = get_mwan3track_status(interface_name, uci_track_ips, procd);
		const track_ips = [];
		for (let ip in uci_track_ips) {
			push(track_ips, {
				'ip': ip,
				'status': get_str(interface_name, sprintf('TRACK_%s', ip)) || 'unknown',
				'latency': get_int(interface_name, sprintf('LATENCY_%s', ip)),
				'packetloss': get_int(interface_name, sprintf('LOSS_%s', ip)),
			});
		}
		result[interface_name] = {
			'age': get_x_time(uptime, interface_name, 'TIME'),
			'online': get_x_time(uptime, interface_name, 'ONLINE'),
			'offline': get_x_time(uptime, interface_name, 'OFFLINE'),
			'uptime': netstatus?.uptime || 0,
			'score': get_int(interface_name, 'SCORE'),
			'lost': get_int(interface_name, 'LOST'),
			'turn': get_int(interface_name, 'TURN'),
			'status': get_str(interface_name, 'STATUS') || 'unknown',
			'enabled': interface_data.config.enabled,
			'running': track_status == 'active',
			'tracking': track_status,
			'up': netstatus?.up || false,
			'track_ip': track_ips,
		};
	}
	return result;
}

const methods = {
	status: {
		args: {
			section: 'section',
			interface: 'interface'
		},
		call: function (request) {
			switch (request.args.section) {
				case 'connected':
					return {
						'connected': {
							'ipv4': get_connected_ips('4'),
							'ipv6': get_connected_ips('6'),
						},
					};
				case 'policies':
					return {
						'policies': {
							'ipv4': get_policies('4'),
							'ipv6': get_policies('6'),
						},
					};
				case 'interfaces':
					return {
						'interfaces': interfaces_status(request),
					};
				default:
					return {
						'interfaces': interfaces_status(request),
						'connected': {
							'ipv4': get_connected_ips('4'),
							'ipv6': get_connected_ips('6'),
						},
						'policies': {
							'ipv4': get_policies('4'),
							'ipv6': get_policies('6'),
						},
					};
			}
		}
	}
};

if (ubus.publish('mwan3', methods) == null) {
	warn(`Error registering mwan3 service: ${ubus.error()}\n`);

	exit(1);
}

while (true) {
	const result = uloop.run();

	if (result == null) {
		warn(`Error occurred during uloop execution: ${uloop.error()}\n`);

		exit(1);
	} else if (result != 0) {
		warn(`Unhandled signal: ${result}; shut down service\n`);

		uloop.end();

		break;
	}
}
