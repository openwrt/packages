#!/bin/sh /etc/rc.common

START=90
STOP=10

USE_PROCD=1
PROG=/usr/lib/ipsec/starter

. $IPKG_INSTROOT/lib/functions.sh
. $IPKG_INSTROOT/lib/functions/network.sh

STRONGSWAN_CONF_FILE=/etc/strongswan.conf
STRONGSWAN_VAR_CONF_FILE=/var/ipsec/strongswan.conf

SWANCTL_CONF_FILE=/etc/swanctl/swanctl.conf
SWANCTL_VAR_CONN_FILE=/var/swanctl/swanctl.conf

WAIT_FOR_INTF=0

time2seconds()
{
	local timestring="$1"
	local multiplier number suffix

	suffix="${timestring//[0-9 ]}"
	number="${timestring%%$suffix}"
	[ "$number$suffix" != "$timestring" ] && return 1
	case "$suffix" in
	""|s)
		multiplier=1 ;;
	m)
		multiplier=60 ;;
	h)
		multiplier=3600 ;;
	d)
		multiplier=86400 ;;
	*)
		return 1 ;;
	esac
	echo $(( number * multiplier ))
}

seconds2time()
{
	local seconds="$1"

	if [ $seconds -eq 0 ]; then
		echo "0s"
	elif [ $((seconds % 86400)) -eq 0 ]; then
		echo "$((seconds / 86400))d"
	elif [ $((seconds % 3600)) -eq 0 ]; then
		echo "$((seconds / 3600))h"
	elif [ $((seconds % 60)) -eq 0 ]; then
		echo "$((seconds / 60))m"
	else
		echo "${seconds}s"
	fi
}

file_reset() {
	: > "$1"
}

xappend() {
	local file="$1"
	shift

	echo "${@}" >> "${file}"
}

swan_reset() {
	file_reset "${STRONGSWAN_VAR_CONF_FILE}"
}

swan_xappend() {
	xappend "${STRONGSWAN_VAR_CONF_FILE}" "$@"
}

swanctl_reset() {
	file_reset "${SWANCTL_VAR_CONN_FILE}"
}

swanctl_xappend() {
	xappend "${SWANCTL_VAR_CONN_FILE}" "$@"
}

warning() {
	echo "WARNING: $@" >&2
}

add_crypto_proposal() {
	local encryption_algorithm
	local hash_algorithm
	local dh_group
	local prf_algorithm

	config_get encryption_algorithm  "$1" encryption_algorithm
	config_get hash_algorithm        "$1" hash_algorithm
	config_get dh_group              "$1" dh_group
	config_get prf_algorithm         "$1" prf_algorithm

	[ -n "$encryption_algorithm" ] && \
		crypto="${crypto:+${crypto},}${encryption_algorithm}${hash_algorithm:+-${hash_algorithm}}${dh_group:+-${dh_group}}${prf_algorithm:+-${prf_algorithm}}"
}

set_crypto_proposal() {
	local conf="$1"
	local proposal
	local crypto=""

	config_list_foreach "$conf" crypto_proposal add_crypto_proposal

	crypto_proposal="$crypto"
}

config_conn() {
	# Generic ipsec conn section shared by tunnel and transport
	local config_name="$1"
	local type="$2"

	local startaction
	local local_subnet
	local local_nat
	local updown
	local firewall
	local remote_subnet
	local remote_sourceip
	local lifetime
	local dpdaction
	local closeaction
	local startaction
	local if_id
	local rekeytime

	config_get startaction              "$1"           startaction "route"
	config_get local_subnet             "$1"           local_subnet ""
	config_get local_nat                "$1"           local_nat ""
	config_get updown                   "$1"           updown ""
	config_get firewall                 "$1"           firewall ""
	config_get remote_subnet            "$1"           remote_subnet ""
	config_get remote_sourceip          "$1"           remote_sourceip ""
	config_get lifetime                 "$1"           lifetime ""
	config_get dpdaction                "$1"           dpdaction "none"
	config_get closeaction              "$1"           closeaction "none"
	config_get if_id                    "$1"           if_id ""
	config_get rekeytime                "$1"           rekeytime ""

	set_crypto_proposal "$1"

	# translate from ipsec to swanctl
	case "$startaction" in
	add)
		startaction="none" ;;
	route)
		startaction="trap" ;;
	start|none|trap)
		# already using new syntax
		;;
	*)
		warning "Mode $mode unknown"
		startaction=
		;;
	esac

	case "$closeaction" in
	none|clear)
		closeaction="none" ;;
	hold)
		closeaction="trap" ;;
	restart)
		closeaction="start" ;;
	trap|start)
		# already using new syntax
		;;
	*)
		warning "Closeaction $closeaction unknown"
		closeaction=
		;;
	esac

	case "$dpdaction" in
	none)
		dpddelay="0s"
		dpdaction=
		;;
	clear)
		;;
	hold)
		dpdaction="trap" ;;
	restart)
		dpdaction="start" ;;
	trap|start)
		# already using new syntax
		;;
	*)
		warning "Dpdaction $dpdaction unknown"
		dpdaction=
		;;
	esac

	[ -n "$local_nat" ] && local_subnet="$local_nat"

	swanctl_xappend "      $config_name {"

	[ -n "$local_subnet" ] && swanctl_xappend "        local_ts = $local_subnet"
	[ -n "$remote_subnet" ] && swanctl_xappend "        remote_ts = $remote_subnet"
	[ -n "$if_id" ] && { swanctl_xappend "        if_id_in = $if_id" ; swanctl_xappend "        if_id_out = $if_id" ; }
	[ -n "$startaction" -a "$startaction" != "none" ] && swanctl_xappend "        start_action = $startaction"
	[ -n "$closeaction" -a "$closeaction" != "none" ] && swanctl_xappend "        close_action = $closeaction"
	swanctl_xappend "        esp_proposals = $crypto_proposal"
	swanctl_xappend "        mode = $type"

	if [ -n "$lifetime" ]; then
		swanctl_xappend "        life_time = $lifetime"
	elif [ -n "$rekeytime" ]; then
		swanctl_xappend "        life_time = $(seconds2time $(((110 * $(time2seconds $rekeytime)) / 100)))"
	fi
	[ -n "$rekeytime" ] && swanctl_xappend "        rekey_time = $rekeytime"

	[ -n "$updown" ] && swanctl_xappend "        updown = $updown"
	[ -n "$dpdaction" ] && swanctl_xappend "        dpd_action = $dpdaction"

        swanctl_xappend "      }"
}

config_tunnel() {
	config_conn "$1" "tunnel"
}

config_transport() {
	config_conn "$1" "transport"
}

config_remote() {
	local config_name="$1"

	local enabled
	local gateway
	local local_gateway
	local local_sourceip
	local local_leftip
	local remote_gateway
	local pre_shared_key
	local auth_method
	local keyingtries
	local dpddelay
	local inactivity
	local keyexchange
	local reqid
	local packet_marker
	local fragmentation
	local mobike
	local local_cert
	local local_key
	local ca_cert
	local if_id
	local rekeytime

	config_get_bool enabled "$1" enabled 0
	[ $enabled -eq 0 ] && return

	config_get gateway           "$1" gateway
	config_get pre_shared_key    "$1" pre_shared_key
	config_get auth_method       "$1" authentication_method
	config_get local_identifier  "$1" local_identifier ""
	config_get remote_identifier "$1" remote_identifier ""
	config_get local_sourceip    "$1" local_sourceip ""
	config_get local_leftip      "$1" local_leftip "%any"
	config_get keyingtries       "$1" keyingtries "3"
	config_get dpddelay          "$1" dpddelay "30s"
	config_get inactivity        "$1" inactivity
	config_get keyexchange       "$1" keyexchange "ikev2"
	config_get reqid             "$1" reqid
	config_get packet_marker     "$1" packet_marker
	config_get fragmentation     "$1" fragmentation "yes"
	config_get_bool mobike       "$1" mobike 1
	config_get local_cert        "$1" local_cert ""
	config_get local_key         "$1" local_key ""
	config_get ca_cert           "$1" ca_cert ""
	config_get if_id             "$1" if_id ""
	config_get rekeytime         "$1" rekeytime
	config_get overtime          "$1" overtime

	case "$fragmentation" in
	0)
		fragmentation="no" ;;
	1)
		fragmentation="yes" ;;
	yes|accept|force|no)
		# already using new syntax
		;;
	*)
		warning "Fragmentation $fragmentation not supported"
		fragmentation=
		;;
	esac

	[ "$gateway" = "any" ] && remote_gateway="%any" || remote_gateway="$gateway"

	[ -z "$local_gateway" ] && {
		local ipdest

		[ "$remote_gateway" = "%any" ] && ipdest="1.1.1.1" || ipdest="$remote_gateway"
		local_gateway=`ip -o route get $ipdest | awk '/ src / { gsub(/^.* src /,""); gsub(/ .*$/, ""); print $0}'`
	}

	set_crypto_proposal "$1"
	ike_proposal="$crypto_proposal"

	[ -n "$firewall" ] && warning "Firewall not supported"

	swanctl_xappend "# config for $config_name"
	swanctl_xappend "connections {"
	swanctl_xappend "  $config_name {"
	swanctl_xappend "    local_addrs = $local_leftip"
	swanctl_xappend "    remote_addrs = $remote_gateway"

	[ -n "$local_sourceip" ] && swanctl_xappend "    vips = $local_sourceip"
	[ -n "$fragmentation" ] && swanctl_xappend "    fragmentation = $fragmentation"
	[ -n "$if_id" ] && { swanctl_xappend "    if_id_in = $if_id" ; swanctl_xappend "    if_id_out = $if_id" ; }

	swanctl_xappend "    local {"
	swanctl_xappend "      auth = $auth_method"

	[ -n "$local_identifier" ] && swanctl_xappend "      id = \"$local_identifier\""
	[ "$auth_method" = pubkey ] && swanctl_xappend "      certs = $local_cert"
	swanctl_xappend "    }"

	swanctl_xappend "    remote {"
	swanctl_xappend "      auth = $auth_method"
	[ -n "$remote_identifier" ] && swanctl_xappend "      id = \"$remote_identifier\""
	swanctl_xappend "    }"

	swanctl_xappend "    children {"

	config_list_foreach "$1" tunnel config_tunnel

	config_list_foreach "$1" transport config_transport

	swanctl_xappend "    }"

	case "$keyexchange" in
	ike)
		;;
	ikev1)
		swanctl_xappend "    version = 1" ;;
	ikev2)
		swanctl_xappend "    version = 2" ;;
	*)
		warning "Keyexchange $keyexchange not supported"
		keyexchange=
		;;
	esac

	[ $mobike -eq 1 ] && swanctl_xappend "    mobike = yes" || swanctl_xappend "    mobike = no"

	if [ -n "$rekeytime" ]; then
		swanctl_xappend "    rekey_time = $rekeytime"

		if [ -z "$overtime" ]; then
			overtime=$(seconds2time $(($(time2seconds $rekeytime) / 10)))
		fi
	fi
	[ -n "$overtime" ] && swanctl_xappend "    over_time = $overtime"

	swanctl_xappend "    proposals = $ike_proposal"
	[ -n "$dpddelay" ] && swanctl_xappend "    dpd_delay = $dpddelay"
	[ "$keyingtries" = "%forever" ] && swanctl_xappend "    keyingtries = 0" || swanctl_xappend "    keyingtries = $keyingtries"

	swanctl_xappend "  }"
	swanctl_xappend "}"

	if [ "$auth_method" = pubkey ]; then
		swanctl_xappend ""

		swanctl_xappend "secrets {"
		swanctl_xappend "  rsa {"
		swanctl_xappend "    filename = $local_key"
		swanctl_xappend "  }"
		swanctl_xappend "}"

		swanctl_xappend ""

		if [ -n "$ca_cert" ]; then
			swanctl_xappend "authorities {"
			swanctl_xappend "  $config_name {"
			swanctl_xappend "    cacert = $ca_cert"
			swanctl_xappend "  }"
			swanctl_xappend "}"
		fi

	elif [ "$auth_method" = psk ]; then
		swanctl_xappend ""

		swanctl_xappend "secrets {"
		swanctl_xappend "  ike {"
		swanctl_xappend "    secret = $pre_shared_key"
		if [ -z "$local_id" ]; then
			swanctl_xappend "    id1 = $local_id"
			if [ -z "$remote_id" ]; then
				swanctl_xappend "    id2 = $remote_id"
			fi
		fi
	else
		warning "AuthenticationMode $auth_mode not supported"
	fi

	swanctl_xappend ""
}

do_resets() {
	swan_reset
	swanctl_reset
}

do_preamble() {
	swanctl_xappend "# generated by /etc/init.d/ipsec"
}

config_ipsec() {
	local debug
	local rtinstall_enabled
	local routing_tables_ignored
	local routing_table
	local routing_table_id
	local interface
	local device_list

	config_get debug "$1" debug 0
	config_get_bool rtinstall_enabled "$1" rtinstall_enabled 1
	[ $rtinstall_enabled -eq 1 ] && install_routes=yes || install_routes=no

	# prepare extra charon config option ignore_routing_tables
	for routing_table in $(config_get "$1" "ignore_routing_tables"); do
		if [ "$routing_table" -ge 0 ] 2>/dev/null; then
			routing_table_id=$routing_table
		else
			routing_table_id=$(sed -n '/[ \t]*[0-9]\+[ \t]\+'$routing_table'[ \t]*$/s/[ \t]*\([0-9]\+\).*/\1/p' /etc/iproute2/rt_tables)
		fi

		[ -n "$routing_table_id" ] && append routing_tables_ignored "$routing_table_id"
	done

	local interface_list=$(config_get "$1" "interface")
	if [ -z "$interface_list" ]; then
		WAIT_FOR_INTF=0
	else
		for interface in $interface_list; do
			network_get_device device $interface
			[ -n "$device" ] && append device_list "$device" ","
		done
		[ -n "$device_list" ] && WAIT_FOR_INTF=0 || WAIT_FOR_INTF=1
	fi

	swan_xappend "# generated by /etc/init.d/ipsec"
	swan_xappend "charon {"
	swan_xappend "  load_modular = yes"
	swan_xappend "  install_routes = $install_routes"
	[ -n "$routing_tables_ignored" ] && swan_xappend "  ignore_routing_tables = $routing_tables_ignored"
	[ -n "$device_list" ] && swan_xappend "  interfaces_use = $device_list"
	swan_xappend "  plugins {"
	swan_xappend "    include /etc/strongswan.d/charon/*.conf"
	swan_xappend "  }"
	swan_xappend "  start-scripts {"
	swan_xappend "    load-all = /usr/sbin/swanctl --load-all"
	swan_xappend "  }"
	swan_xappend "  syslog {"
	swan_xappend "    identifier = ipsec"
	swan_xappend "    daemon {"
	swan_xappend "      default = $debug"
	swan_xappend "    }"
	swan_xappend "  }"
	swan_xappend "}"
}

prepare_env() {
	mkdir -p /var/ipsec /var/swanctl
	do_resets
	do_preamble
	config_load ipsec
	config_foreach config_ipsec ipsec
	config_foreach config_remote remote
}

service_running() {
	swanctl --stats > /dev/null 2>&1
}

reload_service() {
	running && {
		prepare_env
		[ $WAIT_FOR_INTF -eq 0 ] && {
			swanctl --load-all
			return
		}
	}

	start
}

service_triggers() {
	procd_add_reload_trigger "ipsec"
	config load "ipsec"
}

start_service() {
	prepare_env

	[ $WAIT_FOR_INTF -eq 1 ] && return

	procd_open_instance

	procd_set_param command $PROG --daemon charon --nofork

	procd_set_param file $SWANCTL_CONF_FILE
	procd_append_param file /etc/swanctl/conf.d/*.conf
	procd_append_param file $STRONGSWAN_CONF_FILE

	procd_set_param respawn

	procd_close_instance
}
