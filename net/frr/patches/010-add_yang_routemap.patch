--- a/dev/null	2020-04-10 18:48:03.582667900 +0300
+++ b/yang/frr-route-map.yang	2020-05-02 11:43:04.182956847 +0300
@@ -0,0 +1,387 @@
+module frr-route-map {
+  yang-version 1.1;
+  namespace "http://frrouting.org/yang/route-map";
+  prefix frr-route-map;
+
+  import ietf-inet-types {
+    prefix inet;
+  }
+  import frr-filter {
+    prefix filter;
+  }
+  import frr-interface {
+    prefix frr-interface;
+  }
+
+  organization "FRRouting";
+  contact
+    "FRR Users List:       <mailto:frog@lists.frrouting.org>
+     FRR Development List: <mailto:dev@lists.frrouting.org>";
+  description "This module defines route map settings";
+
+  revision 2019-07-01 {
+    description "Initial revision";
+  }
+
+  /*
+   * Types.
+   */
+  typedef route-map-sequence {
+    description "Route map valid sequence numbers";
+    type uint16 {
+      range "1..65535";
+    }
+  }
+
+  typedef route-map-name {
+    description "Route map name format";
+    type string;
+  }
+
+  /*
+   * Operational data.
+   */
+  container lib {
+    list route-map {
+      description "Route map instance";
+
+      key "name";
+
+      leaf name {
+        description "Route map instance name";
+        type route-map-name;
+      }
+
+      list entry {
+        description "Route map entry";
+
+        key "sequence";
+
+        leaf sequence {
+          description
+            "Route map instance priority (low number means higher priority)";
+          type route-map-sequence;
+        }
+
+        leaf description {
+          description "Route map description";
+          type string;
+        }
+
+        leaf action {
+          description
+            "Route map actions: permit (executes action), deny (quits evaluation)";
+          mandatory true;
+          type enumeration {
+            enum permit {
+              description
+                "Executes configured action and permits the prefix/route
+                 if the conditions matched. An alternative exit action can
+                 be configured to continue processing the route map list
+                 or jump to process another route map.";
+              value 0;
+            }
+            enum deny {
+              description
+                "If all conditions are met the prefix/route is denied and
+                 route map processing stops.";
+              value 1;
+            }
+          }
+        }
+
+        leaf call {
+          description
+            "Call another route map before calling `exit-policy`. If the
+             called route map returns deny then this route map will also
+             return deny";
+          type route-map-name;
+        }
+
+        leaf exit-policy {
+          description "What do to after route map successful match, set and call";
+          type enumeration {
+            enum permit-or-deny {
+              description "End route map evaluation and return";
+              value 0;
+            }
+            enum next {
+              description
+                "Proceed evaluating next route map entry per sequence";
+              value 1;
+            }
+            enum goto {
+              description
+                "Go to route map entry with the provided sequence number";
+              value 2;
+            }
+          }
+          default "permit-or-deny";
+        }
+
+        leaf goto-value {
+          when "../exit-policy = 'goto'";
+          description
+            "Sequence number to jump (when using `goto` exit policy)";
+          mandatory true;
+          type route-map-sequence;
+        }
+
+        list match-condition {
+          description "Route map match conditions";
+
+          key "condition";
+
+          leaf condition {
+            description "Match condition";
+            type enumeration {
+              enum interface {
+                description "Match interface";
+                value 0;
+              }
+              enum ipv4-address-list {
+                description "Match an IPv4 access-list";
+                value 1;
+              }
+              enum ipv4-prefix-list {
+                description "Match an IPv4 prefix-list";
+                value 2;
+              }
+              enum ipv4-next-hop-list {
+                description "Match an IPv4 next-hop";
+                value 3;
+              }
+              enum ipv4-next-hop-prefix-list {
+                description "Match an IPv4 next-hop prefix list";
+                value 4;
+              }
+              enum ipv4-next-hop-type {
+                description "Match an IPv4 next-hop type";
+                value 5;
+              }
+              enum ipv6-address-list {
+                description "Match an IPv6 access-list";
+                value 6;
+              }
+              enum ipv6-prefix-list {
+                description "Match an IPv6 prefix-list";
+                value 7;
+              }
+              enum ipv6-next-hop-type {
+                description "Match an IPv6 next-hop type";
+                value 8;
+              }
+              enum metric {
+                description "Match a route metric";
+                value 9;
+              }
+              enum tag {
+                description "Match a route tag";
+                value 10;
+              }
+              /* zebra specific conditions. */
+              enum ipv4-prefix-length {
+                description "Match IPv4 prefix length";
+                value 100;
+              }
+              enum ipv6-prefix-length {
+                description "Match IPv6 prefix length";
+                value 101;
+              }
+              enum ipv4-next-hop-prefix-length {
+                description "Match next-hop prefix length";
+                value 102;
+              }
+              enum source-protocol {
+                description "Match source protocol";
+                value 103;
+              }
+              enum source-instance {
+                description "Match source protocol instance";
+                value 104;
+              }
+            }
+          }
+
+          choice condition-value {
+            description
+              "Value to match (interpretation depends on condition type)";
+            mandatory true;
+            case interface {
+              when "./condition = 'interface'";
+              leaf interface {
+                type string;
+              }
+            }
+            case access-list-num {
+              when "./condition = 'ipv4-address-list' or
+                    ./condition = 'ipv4-next-hop-list'";
+              leaf access-list-num {
+                type filter:access-list-standard;
+              }
+            }
+            case access-list-num-extended {
+              when "./condition = 'ipv4-address-list' or
+                    ./condition = 'ipv4-next-hop-list'";
+              leaf access-list-num-extended {
+                type filter:access-list-extended;
+              }
+            }
+            case list-name {
+              when "./condition = 'ipv4-address-list' or
+                    ./condition = 'ipv4-prefix-list' or
+                    ./condition = 'ipv4-next-hop-list' or
+                    ./condition = 'ipv4-next-hop-prefix-list' or
+                    ./condition = 'ipv6-address-list' or
+                    ./condition = 'ipv6-prefix-list'";
+              leaf list-name {
+                type filter:access-list-name;
+              }
+            }
+            case ipv4-next-hop-type {
+              when "./condition = 'ipv4-next-hop-type'";
+              leaf ipv4-next-hop-type {
+                type enumeration {
+                  enum blackhole {
+                    value 0;
+                  }
+                }
+              }
+            }
+            case ipv6-next-hop-type {
+              when "./condition = 'ipv6-next-hop-type'";
+              leaf ipv6-next-hop-type {
+                type enumeration {
+                  enum blackhole {
+                    value 0;
+                  }
+                }
+              }
+            }
+            case metric {
+              when "./condition = 'metric'";
+              leaf metric {
+                type uint32 {
+                  range "1..4294967295";
+                }
+              }
+            }
+            case tag {
+              when "./condition = 'tag'";
+              leaf tag {
+                type uint32 {
+                  range "1..4294967295";
+                }
+              }
+            }
+          }
+        }
+
+        list set-action {
+          description "Route map set actions";
+
+          key "action";
+
+          leaf action {
+            description "Action to do when the route map matches";
+            type enumeration {
+              enum ipv4-next-hop {
+                description "Set IPv4 address of the next hop";
+                value 0;
+              }
+              enum ipv6-next-hop {
+                description "Set IPv6 address of the next hop";
+                value 1;
+              }
+              enum metric {
+                description "Set prefix/route metric";
+                value 2;
+              }
+              enum tag {
+                description "Set tag";
+                value 3;
+              }
+              /* zebra specific conditions. */
+              enum source {
+                description "Set source address for route";
+                value 100;
+              }
+            }
+          }
+
+          choice action-value {
+            description
+              "Value to set (interpretation depends on action-type)";
+            case ipv4-address {
+              when "./action = 'ipv4-next-hop'";
+              leaf ipv4-address {
+                description "IPv4 address";
+                type inet:ipv4-address;
+              }
+            }
+            case ipv6-address {
+              when "./action = 'ipv6-next-hop'";
+              leaf ipv6-address {
+                description "IPv6 address";
+                type inet:ipv6-address;
+              }
+            }
+            case metric {
+              when "./action = 'metric'";
+              choice metric-value {
+                description "Metric to set or use";
+                case value {
+                  leaf value {
+                    description "Use the following metric value";
+                    type uint32 {
+                      range "0..4294967295";
+                    }
+                  }
+                }
+                case add-metric {
+                  leaf add-metric {
+                    description "Add unit to metric";
+                    type boolean;
+                  }
+                }
+                case subtract-metric {
+                  leaf subtract-metric {
+                    description "Subtract unit from metric";
+                    type boolean;
+                  }
+                }
+                case use-round-trip-time {
+                  leaf use-round-trip-time {
+                    description "Use the round trip time as metric";
+                    type boolean;
+                  }
+                }
+                case add-round-trip-time {
+                  leaf add-round-trip-time {
+                    description "Add round trip time to metric";
+                    type boolean;
+                  }
+                }
+                case subtract-round-trip-time {
+                  leaf subtract-round-trip-time {
+                    description "Subtract round trip time to metric";
+                    type boolean;
+                  }
+                }
+              }
+            }
+            case tag {
+              when "./action = 'tag'";
+              leaf tag {
+                description "Tag value";
+                type uint32 {
+                  range "0..4294967295";
+                }
+              }
+            }
+          }
+        }
+      }
+    }
+  }
+}
